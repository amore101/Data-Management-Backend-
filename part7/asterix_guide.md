# Additional Help for SQL++ and Mondial

The [AsterixDB documentation on SQL++](https://asterixdb.apache.org/docs/0.9.4/sqlpp/manual.html) is a very valuable resource. This guide is only intended to give more tangible examples and explanation as to how SQL++ works and point out probably useful features of SQL++ for the homework. Completing this HW is not at all dependent on the material covered here. You are allowed to use the entirety of SQL++ to complete the assignment.

## Understanding Your Data (`mondial.adm`)

With this assignment it can be easy to accidentally step into the assignment without fully understanding what the starter code is doing. If you do not understand the starter code you may struggle with this assignment when errors seem to appear out of nowhere. The best place to start is to make sure you know what data you are processing.

In your starter code folder, you should have the `mondial.adm` file. This is a very large text file (80000+ lines), so provided is a top view of what you are dealing with:

```json
{
  "mondial": {
    "country": [ ... ],
    "continent": [ ... ],
    "organization": [ ... ],
    "sea": [ ... ],
    "river": [ ... ],
    "lake": [ ... ],
    "island": [ ... ],
    "mountain": [ ... ],
    "desert": [ ... ]
  }
}
```

In addition, your homework spec provides the following code block to correctly setup the data for the majority of the questions:

```sqlp
DROP DATAVERSE geo IF EXISTS;
CREATE DATAVERSE geo;
USE geo;
CREATE TYPE worldType AS {auto_id:uuid };
CREATE DATASET world(worldType) PRIMARY KEY auto_id AUTOGENERATED;
LOAD DATASET world USING localfs (("path"="127.0.0.1://<path to mondial.adm>"),("format"="adm"));
```

When you run the above code, what you are doing is the following:

* Creating a dataverse called "`geo`" (SQL++ speak for a database instance)
* Creating a generic type called "`worldType`". This type is `OPEN` by default, meaning that when we eventually load in data, the "mondial" key in `mondial.adm` will be allowed.
* Creating a dataset called "`world`" which is a collection that will store our to-be single instance of a `worldType`.
* Loading in the local file

It is important moving forward to the actual SQL++ queries that we think about the data in a hierarchical way. Again, we can look at this top view in how we want to access data.

```txt
                   ---------
                   | world |
                   ---------
                       |
                       ------------
                       |          |
                  ----------- --------
                  | mondial | | uuid |
                  ----------- --------
                       |
     -----------------------------------------
     |            |         |        |   |   |
----------- ------------ -------
| country | | mountain | | sea |        ...
----------- ------------ -------
     |            |         |
```

## Understanding the Example Queries

The first query returns the value stored under country.

```sqlp
USE geo;

SELECT X.mondial.country
  FROM world AS X;
```

This is the entire list of countries. Notice that the key-value pair (`"country" : [ ... ]`) is stored as an object. This holds for all other SQL++ queries, so all output intances are their own objects.

---

The next query returns the same thing as before, but now each output object is a single country.

```sqlp
USE geo;

SELECT Y AS country
  FROM world AS X, X.mondial.country AS Y;
```

Why does SQL++ do this? The idea is that when we specify `X.mondial.country AS Y` in the `FROM` clause, we have now accessed a collection (more specifically an array) of countries. The semantics of having a collection in the `FROM` clause is that SQL++ will iterate over all elements in the array.

---

The thrid query given is a copy of the second, except that we grab specific pieces of information from each country.

```sqlp
USE geo;

SELECT Y.`-car_code` AS code, Y.name AS name
  FROM world AS X, X.mondial.country AS Y
 ORDER BY Y.name;
```

This is perhaps one of the most unassuming parts of SQL++. Despite SQL++ working on semi-structured data, the array `X.mondial.country` is treated like a table in the `SELECT` clause. Like how normal SQL has the relational semantics of tables and rigid attributes, SQL++ does the same by treating collections like tables and keys like attributes.

In that same vein of SQL++ being very similar to SQL, most, if not all, of the keywords in SQL are supported via implementation (like `ORDER BY`) or are syntactic sugar (like the `count` function).

---

The next query introduces the `CASE` expression.

```sqlp
USE geo;

SELECT Z.name AS province_name, U.name AS city_name
  FROM world AS X, X.mondial.country AS Y, Y.province AS Z,
       (CASE WHEN is_array(Z.city)
             THEN Z.city
             ELSE [Z.city] END) AS U
 WHERE Y.name = 'Hungary';
```

`CASE` expressions are quite literally if-loops and can go almost anywhere in your query. This is very useful when dealing with heterogeneity. When used in the `FROM` clause, the most common use of `CASE` is to rectify data to take an array format so SQL++ can interpret your query (otherwise a TypeMismatchException will occur).

---

In the final example query, the `LET` keyword is used for the first time.

```sqlp
USE geo;

SELECT Z.name AS province_name, (SELECT cities.name FROM cities) AS cities
  FROM world AS X, X.mondial.country AS Y, Y.province AS Z
   LET cities = (CASE WHEN Z.city IS MISSING
                      THEN []
                      WHEN is_array(Z.city)
                      THEN Z.city
                      ELSE [Z.city] END)
 WHERE Y.name = 'Hungary';
```

Using `LET` is a simple and concise way to create virtual "tables". The reason why SQL++ included this was to deal with the difficulties of hierarchical data access as evidenced in this example where the "virtual table" was built from items already in the `FROM` clause. Note that we could not generate similar logic easily or concisely with a `FROM` or `WITH` subquery. Notice that in the example above, the `CASE` expression in the `LET` clause uses `Z` which is data derived in the `FROM` clause (something we cannot do in `FROM` or `WITH`). Note that the `cities` "virtual table" is also correlated to the specific value of `Z`, a useful property when extracting output.

## New Keywords in SQL++

SQL++ boasts a huge increase in functionality over standard SQL. With that functionality comes new components to the language that you should become familiar with.

* \` `...` \` Escape character called backtick for accessing keys with characters like `-` or `#` in them.
* `MISSING` A reserved keyword like `NULL`. Can be used in comparisons like `x IS NOT MISSING`.
* `is_array( ... )` A function to check if the value is an array or not.
* `split( s , d )` A function to split a string `s` by the delimiter `d`. Needed for aquiring country codes that are listed together in a single string.
* `CASE WHEN ... THEN ... [WHEN ... THEN ...] ELSE ... END` An expression to output values based on `WHEN` predicates.
* `LET x = ...` Like a `WITH` subquery, but with the ability to utilize the data specified in the `FROM` clause.

## Aggregations in SQL++

Most all the aggregation in this homework will be counting. 

* `strict_count( ... )` Counts the number of elements in an array (including `NULL` and `MISSING`)
* `array_count( ... )` Counts the number of elements in an array (not including `NULL` and `MISSING`)
* `count( ... )` This function is supported as syntactic sugar for `ARRAY_COUNT( (SELECT VALUE 1 FROM $1 AS G) )`

Note that these functions only work on array types. Usually how you can take advantage of these functions is by using `LET` to generate the array you want. For example if we wanted to find the total number of member countries in each organization:

```sqlp
USE geo;
SELECT T.id, sum(T.num_members) AS total_members
FROM (SELECT Y.`-id` AS id, strict_count(arr) AS num_members
        FROM world AS X, X.mondial.organization AS Y,
             (CASE WHEN is_array(Y.members)
                   THEN Y.member
                   ELSE [Y.members] END) AS Z
         LET arr = split(Z.`-country`, ' ')) AS T
GROUP BY T.id;
```

## Notes on how to formulate your solutions

We do not have a style guide for SQL++ besides to follow the conventions of normal SQL. Make sure you make line breaks for most of your keywords (as appropriate). We will be lax with syntax for this HW. Above all, just make your code readable.

Formatting your answers can be hard and grabbing exactly the data you want is not always concise. Don't be afraid to use subqueries wherever you need them. In fact correlated subqueries, if use correctly in this homework will actually make some queries run extremely fast!

